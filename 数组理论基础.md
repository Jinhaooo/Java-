# Java 数组理论基础
## 数组在内存中的本质
### 1.数组本身是一个对象
数组继承自Object类，有自己的数据类型，数组对象存储在堆内存中，而数组变量则作为引用，存储在栈内存中。

### 2.数组在堆内存中的存储方式
当你创建一个数组时，比如int[] arr = new int[5]，内存中会发生以下事情：  
栈内存：  
存储变量arr，它是一个引用（地址），占用4字节（32位系统）或8字节（64位系统）  
堆内存：
存储实际的数组对象，包含三部分：
对象头（Object Header）：包含Mark Word（锁信息、GC信息等）和类型指针（指向数组的Class对象）
数组长度：一个int值（4字节），存储数组的长度
数组数据：连续的内存空间，存储实际的元素
堆内存布局示例（int[5]）：
┌─────────────────┐  
│   对象头(12字节) │  
├─────────────────┤  
│  数组长度: 5    │  (4字节)  
├─────────────────┤  
│  arr[0]         │  (4字节)  
├─────────────────┤  
│  arr[1]         │  (4字节)  
├─────────────────┤  
│  arr[2]         │  (4字节)  
├─────────────────┤  
│  arr[3]         │  (4字节)  
├─────────────────┤  
│  arr[4]         │  (4字节)  
└─────────────────┘  

### 3.数组运算性能
知道了数组的存储方式后，我们发现数组数据是在连续的内存空间中的，这就使得随机访问很快，是O(1)的时间复杂度，如：  
元素地址 = 数组起始地址 + (索引 × 元素大小) 一次乘法和一次加法即可。  
而现代CPU有多级缓存（L1、L2、L3）。当你访问arr[0]时，CPU会将arr[0]及其附近的内存一起加载到缓存行中（通常64字节）。如果接下来访问arr[1]、arr[2]等，这些数据已经在缓存中了，访问速度极快。这也是为什么顺序访问比随机访问快得多。  
需要注意的是，当数组中存储的不是基本数据类型而是对象时，堆中实际连续存储的是对象的引用，因此随机访问时，需要找到引用后再根据引用找到数据，也就失去了连续内存存储的性能优势了。 

### 4.数组的初始化
数组会自动初始化。底层逻辑是：  
int[] arr = new int[1000];  
JVM会：  
计算所需内存大小 = 对象头 + 数组长度字段 + (1000 × 4字节)  
在堆中分配连续内存块  
将整块内存清零  
设置对象头信息  
设置数组长度为1000  
返回数组对象的引用  
需要注意的是数组的长度，理论上数组的长度受int类型限制，但实际上是Integer.MAX_VALUE - 5。因为需要预留更多的空间来存储对象头和对象长度，以及一些内部操作空间。而且由于堆内存的内存空间是碎片化的，可能找不到足够的连续空间。  

### 5.数组的一些限制
数组是不可变的，因为数组长度存储在对象内部的固定位置，数组在内存中占据连续空间，扩容意味着需要重新分配内存，且无法在原地扩展（后面的内存可能已被占用），如果需要扩容，只能创建新数组并复制元素：  
int[] newArr = new int[oldArr.length * 2];  
System.arraycopy(oldArr, 0, newArr, 0, oldArr.length);  
不能有泛型数组，运行时泛型信息会被擦除，无法保证类型安全。数组在运行时需要知道元素的确切类型（用于类型检查），而泛型在运行时类型信息已丢失，两者冲突。  

### 6.数组的性能
空间局部性：顺序访问数组比跳跃访问快得多  
对象开销：每个数组对象都有对象头开销（约16字节）  
基本类型优先：int[]比Integer[]节省内存且性能更好（避免自动装箱）  
大数组分配：大数组可能触发Full GC，因为需要连续的大块内存  


